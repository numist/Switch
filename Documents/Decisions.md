# Decisions

This file exists to provide a historical record of the motivation for important technical decisions in the project. It's inspired by Architectural Decision Records, but with minimal bureaucracy:

* New decisions are appended to the file
* Existing decisions may not be edited (but they can be superceded)

### Contents:

* [Isolated, Reactive Switcher State Machine](#isolated--reactive-switcher-state-machine)
* [Value Types for Windows and Window Groups](#value-types-for-windows-and-window-groups)
* [Integrated Dependencies](#integrated-dependencies)

<!-- ToC generated by http://ecotrust-canada.github.io/markdown-toc/ --->

## Isolated, Reactive Switcher State Machine

The switcher's window management behaviour and interface display logic represent a state machine each, the combination of which quickly becomes difficult to manage when integrated with a traditional MVC controller.

This implementation complexity is what led to the use of FRP in Switch, assisted at the time by Reactive Cocoa and now implemented in standalone Swift. A basic fuzzer has provided valuable testing coverage, uncovering issues during development that defy imagination.

While the state machine code is still imperative, its isolation combined with a values-in/callbacks-out architecture has significantly improved product quality and code readability.

## Value Types for Windows and Window Groups

Earlier versions of Switch were difficult to validate due to the inability to represent certain system states in the test environment. Specifically, traits like "app is active" or "app can be activated" weren't encoded in value types that could be used in unit tests.

Having watched [Boundaries](https://www.destroyallsoftware.com/talks/boundaries), and realizing that the success of the [state machine implementation](#isolated--reactive-switcher-state-machine) was the result of moving closer to a functional core/imperative shell model, Switch's transition to Swift included value types for representing _all_ aspects of windows, window groups, and applications. The resulting architecture is _much_ easier to test, and does not appear to suffer from the additional overhead of gathering occasionally-unused pieces of information to populate the values.

## Integrated Dependencies

After a string of bad experiences over the years with `git submodule`, dependency deaths, and overly-clever tooling all contributing to widespread bitrot breaking the build, I have settled on the dumbest solution I can think of:

### All of Switch's dependencies are checked into its repository.

The goal is that people should be able to get up and running with a `git clone`, `open Switch.xcworkspace`, and `âŒ˜R`.
