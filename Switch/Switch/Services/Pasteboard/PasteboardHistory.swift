import Cocoa
import OSLog
import SQLite

private extension Set {
  func intersects(_ other: Self) -> Bool {
    let smaller = self.count < other.count ? self : other
    let larger = self.count < other.count ? other : self
    for element in smaller {
      if larger.contains(element) { return true }
    }
    return false
  }
}

/*
 DELETE FROM pasteboardItems WHERE used < ?
 SELECT appName, bundleId, snippet,
   datetime(used, 'unixepoch', 'localtime') as used,
   datetime(created, 'unixepoch', 'localtime') AS created
 FROM pasteboardItems WHERE snippet LIKE '%?%' ORDER BY used DESC LIMIT ?

 What's the perf implication of super fuzzy search? May as well allow wildcards in the query str

 [pasteboard setString: @"org.nspasteboard.SampleApp" forType: @"org.nspasteboard.source"];

 if let path = workspace.absolutePathForApplication(withBundleIdentifier:bundleId) {
   print("icon for app \(bundleId): \(workspace.icon(forFile: path))")
 }
 */

class PasteboardHistory {
  private var sizeLimit = 1024
  private var capacityLimit = 1024
  private var expiration = Date()

  private var changeCount: Int!
  private var mouseClickEventTap: EventTap! = nil

  // SQLite stuff
  fileprivate var db: SQLite.Connection! // swiftlint:disable:this identifier_name
  private var insertStmt: SQLite.Statement!

  private func recordPasteboard() {
    let pasteboard = NSPasteboard.general
    guard changeCount != pasteboard.changeCount else { return }
    changeCount = pasteboard.changeCount

    if let source = pasteboard.string(forType: .init(rawValue: "org.nspasteboard.source")) {
      print("actual source of item: \(source)")
    }

    // Courtesy http://nspasteboard.org, maybe we can get listed there someday
    let filteredTypes: Set<String> = [
      "org.nspasteboard.TransientType",
      "org.nspasteboard.ConcealedType",
      "org.nspasteboard.AutoGeneratedType",
      "org.nspasteboard.source",
      "com.agilebits.onepassword",
      "de.petermaurer.TransientPasteboardType",
      "com.typeit4me.clipping",
      "Pasteboard generator type",
    ]
    let types = Set(pasteboard.types!.map { $0.rawValue })
    if types.intersects(filteredTypes) {
      os_log(.info, "filtered type identifier, skipping")
      return
    }

    // Other available types include:
    // NSPasteboard.PasteboardType.string
    // NSPasteboard.PasteboardType.pdf
    // NSPasteboard.PasteboardType.tiff
    // NSPasteboard.PasteboardType.png
    // NSPasteboard.PasteboardType.rtf
    // NSPasteboard.PasteboardType.rtfd
    // NSPasteboard.PasteboardType.html
    // NSPasteboard.PasteboardType.tabularText
    // NSPasteboard.PasteboardType.font
    // NSPasteboard.PasteboardType.ruler
    // NSPasteboard.PasteboardType.color
    // NSPasteboard.PasteboardType.sound
    // NSPasteboard.PasteboardType.multipleTextSelection
    // NSPasteboard.PasteboardType.textFinderOptions
    // NSPasteboard.PasteboardType.URL
    // NSPasteboard.PasteboardType.fileURL
    // But for now we'll just grab NSStringPboardType, if available.
    guard let item = pasteboard.string(forType: .string) else {
      os_log(.info, "no item for type NSStringPboardType, skipping")
      return
    }
    if item.allSatisfy({ $0.isWhitespace }) {
      os_log(.info, "item is all whitespace, skipping")
      return
    }
    if item.count > sizeLimit {
      os_log(.info, "item is too big, skipping")
      return
    }

    // TODO(numist): better app attribution for menu items and immediate-dismiss apps (like Dropbox menu)
    let frontmostApp = NSWorkspace.shared.frontmostApplication!
    let appName = frontmostApp.localizedName ?? "(unknown)"
    let appBundle = frontmostApp.bundleIdentifier ?? "(unknown)"
    // Get off the main thread when doing I/O
    DispatchQueue.global(qos: .userInitiated).async {
      do {
        try self.insertStmt.run(appName, appBundle, item)
      } catch {
        // TODO(numist): unify logging shenanigans (macOS 11.0?)
        print("Unexpected error inserting item: \(error)")
        // Drop item.
        return
      }
      os_log(.info, "recorded pasteboard item")
    }
  }

  private let viewHistory: (Bool) -> Bool = { keyDown in
    return false
  }

  init() {
    do {
      let dir = try setUpAppSupportDir()
      try setUpDatabase(in: dir)
    } catch {
      // TODO(numist): error handling, especially db corruption but also filemanager stuff
      print("Unexpected error: \(error)")
      exit(1)
    }

    changeCount = NSPasteboard.general.changeCount

    mouseClickEventTap = try? EventTap(observing: .leftMouseUp, callback: { (_, event) -> CGEvent? in
      // Longish timeout required because Copy menu items don't appear to
      // actually copy until the menu has finished animating out
      DispatchQueue.main.asyncAfter(deadline: .now() + 0.50) {
        self.recordPasteboard()
      }
      return event
    })

    let asyncAndRecord: (Bool) -> Bool = { _ in
      DispatchQueue.main.asyncAfter(deadline: .now()) {
        self.recordPasteboard()
      }
      return true
    }
    Keyboard.register(.init(.command, .x), asyncAndRecord)
    Keyboard.register(.init(.command, .c), asyncAndRecord)
    Keyboard.register(.init([.command, .option], .v)) { keyDown in
      if keyDown {
        DispatchQueue.main.async {
          // TODO(numist): rubber, meet road
          print("Want to paste from history")
        }
      }
      return false
    }
  }

  deinit {
    Keyboard.deregister(.init(.command, .x))
    Keyboard.deregister(.init(.command, .c))
    Keyboard.deregister(.init([.command, .option], .v))
  }

  private func setUpAppSupportDir() throws -> URL {
    let fileManager = FileManager.default
    let appSup = fileManager.urls(for: .applicationSupportDirectory, in: .userDomainMask)
      .first!.appendingPathComponent(Bundle.main.bundleIdentifier!)
    var isDir: ObjCBool = true
    var exists = fileManager.fileExists(atPath: appSup.path, isDirectory: &isDir)
    if exists && isDir.boolValue == false {
      try fileManager.removeItem(at: appSup)
      exists = false
    }
    if !exists {
      try fileManager.createDirectory(at: appSup, withIntermediateDirectories: true, attributes: nil)
    }
    return appSup
  }

  private func setUpDatabase(in dir: URL) throws {
    db = try SQLite.Connection(dir.appendingPathComponent("Pasteboard History.sqlite").path)
    db.busyTimeout = 1.0
    try db.execute("PRAGMA user_version=1")
    try db.execute("PRAGMA journal_mode=wal")
    try db.execute("""
      CREATE TABLE IF NOT EXISTS pasteboardItems (
        appname  STRING,
        bundleId STRING,
        snippet  STRING UNIQUE,
        created  INT8 DEFAULT (strftime('%s', 'now')),
        used     INT8 DEFAULT (strftime('%s', 'now'))
      )
    """)
    try db.execute("""
      CREATE INDEX IF NOT EXISTS pasteboardItems_used ON pasteboardItems(used DESC)
    """)
    insertStmt = try db.prepare("""
      INSERT INTO pasteboardItems (appname, bundleId, snippet)
      VALUES(?, ?, ?)
      ON CONFLICT(snippet) DO
        UPDATE SET used = strftime('%s', 'now')
    """)
  }
}

struct PasteboardItem: Identifiable {
  let id: Int64 // swiftlint:disable:this identifier_name
  let appName: String
  let appBundle: String
  let snippet: String
  let created: Date
  let lastUsed: Date
}

// swiftlint:disable force_try
// swiftlint:disable force_cast
extension PasteboardHistory {
  func getItems(for query: String) -> [PasteboardItem] {
    let stmt = try! db.prepare("""
    SELECT rowid, * FROM pasteboardItems WHERE snippet LIKE ? ORDER BY used DESC LIMIT 20
    """)
    var result = [PasteboardItem]()
    for row in stmt.bind(query.isEmpty ? "%" : "%"+query+"%") {
      print(row)
      result.append(PasteboardItem(
        id: row[0] as! Int64,
        appName: row[1] as! String,
        appBundle: row[2] as! String,
        snippet: row[3] as! String,
        created: Date(timeIntervalSince1970: TimeInterval(row[4] as! Int64)),
        lastUsed: Date(timeIntervalSince1970: TimeInterval(row[5] as! Int64))
      ))
    }
    return result
  }
}
