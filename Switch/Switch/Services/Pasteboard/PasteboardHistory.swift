import Cocoa
import OSLog
import CoreData

private extension Set {
  func intersects(_ other: Self) -> Bool {
    let smaller = self.count < other.count ? self : other
    let larger = self.count < other.count ? other : self
    for element in smaller {
      if larger.contains(element) { return true }
    }
    return false
  }
}

/*
 DELETE FROM pasteboardItems WHERE used < ?
 SELECT appName, bundleId, snippet,
   datetime(used, 'unixepoch', 'localtime') as used,
   datetime(created, 'unixepoch', 'localtime') AS created
 FROM pasteboardItems WHERE snippet LIKE '%?%' ORDER BY used DESC LIMIT ?

 What's the perf implication of super fuzzy search? May as well allow wildcards in the query str

 [pasteboard setString: @"org.nspasteboard.SampleApp" forType: @"org.nspasteboard.source"];

 if let path = workspace.absolutePathForApplication(withBundleIdentifier:bundleId) {
   print("icon for app \(bundleId): \(workspace.icon(forFile: path))")
 }
 */

class PasteboardHistory {
  private var sizeLimit = 1024
  private var capacityLimit = 1024
  private var expiration = Date()

  private var changeCount: Int!
  private var mouseClickEventTap: EventTap! = nil

  private func recordPasteboard() {
    let pasteboard = NSPasteboard.general
    guard changeCount != pasteboard.changeCount else { return }
    changeCount = pasteboard.changeCount

    if let source = pasteboard.string(forType: .init(rawValue: "org.nspasteboard.source")) {
      print("actual source of item: \(source)")
    }

    // Courtesy http://nspasteboard.org, maybe we can get listed there someday
    let filteredTypes: Set<String> = [
      "org.nspasteboard.TransientType",
      "org.nspasteboard.ConcealedType",
      "org.nspasteboard.AutoGeneratedType",
      "org.nspasteboard.source",
      "com.agilebits.onepassword",
      "de.petermaurer.TransientPasteboardType",
      "com.typeit4me.clipping",
      "Pasteboard generator type",
    ]
    let types = Set(pasteboard.types!.map { $0.rawValue })
    if types.intersects(filteredTypes) {
      os_log(.info, "filtered type identifier, skipping")
      return
    }

    // Other available types include:
    // NSPasteboard.PasteboardType.string
    // NSPasteboard.PasteboardType.pdf
    // NSPasteboard.PasteboardType.tiff
    // NSPasteboard.PasteboardType.png
    // NSPasteboard.PasteboardType.rtf
    // NSPasteboard.PasteboardType.rtfd
    // NSPasteboard.PasteboardType.html
    // NSPasteboard.PasteboardType.tabularText
    // NSPasteboard.PasteboardType.font
    // NSPasteboard.PasteboardType.ruler
    // NSPasteboard.PasteboardType.color
    // NSPasteboard.PasteboardType.sound
    // NSPasteboard.PasteboardType.multipleTextSelection
    // NSPasteboard.PasteboardType.textFinderOptions
    // NSPasteboard.PasteboardType.URL
    // NSPasteboard.PasteboardType.fileURL
    // But for now we'll just grab NSStringPboardType, if available.
    guard let snippet = pasteboard.string(forType: .string) else {
      os_log(.info, "no item for type NSStringPboardType, skipping")
      return
    }
    if snippet.allSatisfy({ $0.isWhitespace }) {
      os_log(.info, "item is all whitespace, skipping")
      return
    }
    if snippet.count > sizeLimit {
      os_log(.info, "item is too big, skipping")
      return
    }

    // TODO(numist): better app attribution for menu items and immediate-dismiss apps (like Dropbox menu)
    let frontmostApp = NSWorkspace.shared.frontmostApplication!
    let appBundle = frontmostApp.bundleIdentifier ?? "net.numist.bundle.unknown"
    // Get off the main thread when doing I/O
    PasteboardHistory.persistentContainer.performBackgroundTask { context in
      context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
      let item = PasteboardItem(context: context)
      item.appBundle = appBundle
      item.snippet = snippet
      item.lastUsed = Date()
      // TODO(numist): possible for db corruption to manifest here and not anywhere else
      try? context.save()
      os_log(.info, "recorded pasteboard item")
    }
  }

  private let viewHistory: (Bool) -> Bool = { keyDown in
    return false
  }

  static var persistentContainer: NSPersistentContainer = {
    let container = NSPersistentContainer(name: "PasteboardHistory")
    container.loadPersistentStores(completionHandler: { (_, error) in
      if let error = error as NSError? {
        // Replace this implementation with code to handle the error appropriately.
        // fatalError() causes the application to generate a crash log and terminate.
        // You should not use this function in a shipping application, although it may be useful during development.

        /*
         Typical reasons for an error here include:
         * The parent directory does not exist, cannot be created, or disallows writing.
         * The persistent store is not accessible, due to permissions or data protection when the device is locked.
         * The device is out of space.
         * The store could not be migrated to the current model version.
         Check the error message to determine what the actual problem was.
         */
        fatalError("Unresolved error \(error), \(error.userInfo)")
      }
    })
    return container
  }()

  init() {
    changeCount = NSPasteboard.general.changeCount

    mouseClickEventTap = try? EventTap(observing: .leftMouseUp, callback: { (_, event) -> CGEvent? in
      // Longish timeout required because Copy menu items don't appear to
      // actually copy until the menu has finished animating out
      DispatchQueue.main.asyncAfter(deadline: .now() + 0.50) {
        self.recordPasteboard()
      }
      return event
    })

    let asyncAndRecord: (Bool) -> Bool = { _ in
      DispatchQueue.main.async {
        self.recordPasteboard()
      }
      return true
    }
    Keyboard.register(.init(.command, .x), asyncAndRecord)
    Keyboard.register(.init(.command, .c), asyncAndRecord)
    Keyboard.register(.init([.command, .option], .v)) { keyDown in
      if keyDown {
        DispatchQueue.main.async {
          // TODO(numist): rubber, meet road
          print("Want to paste from history")
        }
      }
      return false
    }

    PasteboardHistory.persistentContainer.viewContext.automaticallyMergesChangesFromParent = true
  }

  deinit {
    Keyboard.deregister(.init(.command, .x))
    Keyboard.deregister(.init(.command, .c))
    Keyboard.deregister(.init([.command, .option], .v))
  }
}

extension PasteboardItem {
  var unwrappedSnippet: String { snippet! }
  var unwrappedAppBundle: String { appBundle! }
}
